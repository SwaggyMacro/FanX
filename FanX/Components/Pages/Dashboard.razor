@page "/"
@page "/dashboard"
@using FanX.Resources
@using FanX.Models.DTO
@using System.Linq
@using ApexCharts
@attribute [Authorize]
@implements IDisposable
@inject LocalizationService LocalizationService
@inject IServiceScopeFactory ScopeFactory
@inject ThemeService ThemeService

<PageTitle>@Localization.Dashboard</PageTitle>

<MudText Typo="Typo.h5" GutterBottom="true">@Localization.Dashboard</MudText>

<!-- Live Status Section -->
<MudGrid Spacing="3" Class="mb-4">
    <MudItem xs="12">
        <MudText Typo="Typo.h6">Live Status</MudText>
    </MudItem>

    <MudItem xs="12" md="6">
        <MudStack Spacing="3">
            <MudCard>
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">@Localization.Power</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    @if (_isLiveDataLoading)
                    {
                        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100px" />
                    }
                    else if (_livePowerData != null)
                    {
                        <MudPaper Class="pa-3">
                            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    <MudIcon Icon="@Icons.Material.Filled.Power" Color="MudBlazor.Color.Error"/>
                                    <MudText Typo="Typo.body1">@_livePowerData.SensorName</MudText>
                                </MudStack>
                                <MudText Typo="Typo.h5">@_livePowerData.Reading.ToString("F1") W</MudText>
                            </MudStack>
                            @if (_isStatsLoading)
                            {
                                <MudSkeleton Width="100%" Height="20px" Class="mt-2" />
                                <MudSkeleton Width="60%" Height="20px" Class="mt-1" />
                            }
                            else
                            {
                                <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-2" Wrap="Wrap.Wrap">
                                    <MudText Typo="Typo.caption">Avg (1h): @_powerAverages.Hour.ToString("F1") W</MudText>
                                    <MudText Typo="Typo.caption">Avg (24h): @_powerAverages.Day.ToString("F1") W</MudText>
                                    <MudText Typo="Typo.caption">Avg (7d): @_powerAverages.Week.ToString("F1") W</MudText>
                                    <MudText Typo="Typo.caption">Avg (30d): @_powerAverages.Month.ToString("F1") W</MudText>
                                </MudStack>
                                <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-1" Wrap="Wrap.Wrap">
                                    <MudText Typo="Typo.caption">Min: @_powerAverages.Min.ToString("F1") W</MudText>
                                    <MudText Typo="Typo.caption">Max: @_powerAverages.Max.ToString("F1") W</MudText>
                                </MudStack>
                            }
                        </MudPaper>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="MudBlazor.Color.Secondary">No data available</MudText>
                    }
                </MudCardContent>
            </MudCard>

            <MudCard>
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h6">@Localization.Temperature</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    @if (_isLiveDataLoading)
                    {
                        <MudStack Spacing="2">
                            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="80px" />
                            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="80px" />
                        </MudStack>
                    }
                    else
                    {
                        <MudStack Spacing="2">
                            @foreach (var sensor in _liveCpuData)
                            {
                                <MudPaper Class="pa-3">
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                            <MudIcon Icon="@Icons.Material.Filled.Thermostat" Color="MudBlazor.Color.Warning"/>
                                            <MudText Typo="Typo.body1">@sensor.SensorName</MudText>
                                        </MudStack>
                                        <MudText Typo="Typo.h5">@sensor.Reading.ToString("F1") °C</MudText>
                                    </MudStack>
                                    @if (_isStatsLoading || !_tempAverages.ContainsKey(sensor.SensorName ?? ""))
                                    {
                                        <MudSkeleton Width="100%" Height="20px" Class="mt-2" />
                                    }
                                    else
                                    {
                                        var avg = _tempAverages[sensor.SensorName ?? ""];
                                        <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-2" Wrap="Wrap.Wrap">
                                            <MudText Typo="Typo.caption">Avg (1h): @avg.Hour.ToString("F1") °C</MudText>
                                            <MudText Typo="Typo.caption">Avg (24h): @avg.Day.ToString("F1") °C</MudText>
                                            <MudText Typo="Typo.caption">Avg (7d): @avg.Week.ToString("F1") °C</MudText>
                                            <MudText Typo="Typo.caption">Avg (30d): @avg.Month.ToString("F1") °C</MudText>
                                        </MudStack>
                                        <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-1" Wrap="Wrap.Wrap">
                                            <MudText Typo="Typo.caption">Min: @avg.Min.ToString("F1") °C</MudText>
                                            <MudText Typo="Typo.caption">Max: @avg.Max.ToString("F1") °C</MudText>
                                        </MudStack>
                                    }
                                </MudPaper>
                            }
                        </MudStack>
                    }
                </MudCardContent>
            </MudCard>
        </MudStack>
    </MudItem>

    <MudItem xs="12" md="6">
        <MudCard Style="height: 100%">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">@Localization.Fans</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                @if (_isLiveDataLoading)
                {
                    <MudStack Spacing="2">
                        @for (int i = 0; i < 4; i++)
                        {
                            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="100px" />
                        }
                    </MudStack>
                }
                else
                {
                    <MudStack Spacing="2">
                        @foreach (var sensor in _liveFanData)
                        {
                            <MudPaper Class="pa-3">
                                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                        <MudIcon Icon="@Icons.Material.Filled.Air" Color="MudBlazor.Color.Info"/>
                                        <MudText Typo="Typo.body1">@sensor.SensorName</MudText>
                                    </MudStack>
                                    <MudText Typo="Typo.h5">@sensor.Reading.ToString("F0") RPM</MudText>
                                </MudStack>
                                @if (_isStatsLoading || !_fanAverages.ContainsKey(sensor.SensorName ?? ""))
                                {
                                    <MudSkeleton Width="100%" Height="20px" Class="mt-2" />
                                }
                                else
                                {
                                    var avg = _fanAverages[sensor.SensorName ?? ""];
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-2" Wrap="Wrap.Wrap">
                                        <MudText Typo="Typo.caption">Avg (1h): @avg.Hour.ToString("F0") RPM</MudText>
                                        <MudText Typo="Typo.caption">Avg (24h): @avg.Day.ToString("F0") RPM</MudText>
                                        <MudText Typo="Typo.caption">Avg (7d): @avg.Week.ToString("F0") RPM</MudText>
                                        <MudText Typo="Typo.caption">Avg (30d): @avg.Month.ToString("F0") RPM</MudText>
                                    </MudStack>
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-1" Wrap="Wrap.Wrap">
                                        <MudText Typo="Typo.caption">Min: @avg.Min.ToString("F0") RPM</MudText>
                                        <MudText Typo="Typo.caption">Max: @avg.Max.ToString("F0") RPM</MudText>
                                    </MudStack>
                                }
                                @if (sensor.Pwm.HasValue)
                                {
                                    <MudProgressLinear Color="MudBlazor.Color.Primary" Value="@sensor.Pwm.Value" Class="my-1"/>
                                    <MudText Typo="Typo.body2" Align="MudBlazor.Align.End">@sensor.Pwm.Value.ToString("F0")%</MudText>
                                }
                            </MudPaper>
                        }
                    </MudStack>
                }
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

<!-- Charts Section -->
<MudGrid Spacing="3" Class="mb-4">
    <MudItem xs="12">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudText Typo="Typo.h6">Historical Data</MudText>
            <MudStack Row="true" Spacing="2">
                <MudIconButton Icon="@Icons.Material.Filled.Refresh" 
                              Color="MudBlazor.Color.Primary" 
                              OnClick="ManualRefreshCharts"
                              Disabled="_isChartLoading"
                              Title="Refresh Charts" />
                <MudSelect T="int" Value="_selectedTimeRange" ValueChanged="OnTimeRangeChanged" 
                          Label="Chart Time Range" Variant="Variant.Outlined" Margin="Margin.Dense" Disabled="_isChartLoading">
                    <MudSelectItem Value="1">@string.Format(Localization.LastHours, 1)</MudSelectItem>
                    <MudSelectItem Value="6">@string.Format(Localization.LastHours, 6)</MudSelectItem>
                    <MudSelectItem Value="24">@string.Format(Localization.LastHours, 24)</MudSelectItem>
                    <MudSelectItem Value="168">@string.Format(Localization.LastDays, 7)</MudSelectItem>
                    <MudSelectItem Value="720">@string.Format(Localization.LastDays, 30)</MudSelectItem>
                </MudSelect>
            </MudStack>
        </MudStack>
    </MudItem>
</MudGrid>

<MudGrid Spacing="3">
    <MudItem xs="12" md="4">
        <MudStack Spacing="3">
            <MudPaper Class="pa-3">
                <MudText Typo="Typo.h6">@Localization.TemperatureHistory</MudText>
                @if (_isChartLoading)
                {
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px" Class="mt-2" />
                }
                else
                {
                    <ApexChart TItem="ChartDataPoint" Options="_temperatureChartOptions" @ref="_temperatureChart">
                        @foreach (var series in _chartData.Where(d => d.S == "Temperature").GroupBy(d => d.N))
                        {
                            <ApexPointSeries TItem="ChartDataPoint" Items="series.ToList()" Name="@series.Key"
                                             XValue="@(item => item.T)"
                                             YValue="@(item => Convert.ToDecimal(item.V))"/>
                        }
                    </ApexChart>
                }
            </MudPaper>
            <MudPaper Class="pa-3">
                <MudText Typo="Typo.h6">@Localization.PowerHistory</MudText>
                @if (_isChartLoading)
                {
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px" Class="mt-2" />
                }
                else
                {
                    <ApexChart TItem="ChartDataPoint" Options="_powerChartOptions" @ref="_powerChart">
                        <ApexPointSeries TItem="ChartDataPoint"
                                         Items="@(_chartData.Where(d => d.N == "Pwr Consumption").ToList())"
                                         Name="Power Consumption"
                                         XValue="@(item => item.T)"
                                         YValue="@(item => Convert.ToDecimal(item.V))"/>
                    </ApexChart>
                }
            </MudPaper>
        </MudStack>
    </MudItem>

    <MudItem xs="12" md="8">
        <MudPaper Class="pa-3 d-flex flex-column" Style="height: 100%">
            <MudText Typo="Typo.h6" GutterBottom="true">@Localization.FanSpeedHistory</MudText>
            @if (_isChartLoading)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="400px" Class="mt-2" />
            }
            else
            {
                <ApexChart TItem="ChartDataPoint" Options="_fanChartOptions" @ref="_fanChart">
                    @foreach (var series in _chartData.Where(d => d.S == "Fan" && d.N != "Fan Redundancy").GroupBy(d => d.N))
                    {
                        <ApexPointSeries TItem="ChartDataPoint" Items="series.ToList()" Name="@series.Key"
                                         XValue="@(item => item.T)"
                                         YValue="@(item => Convert.ToDecimal(item.V))"/>
                    }
                </ApexChart>
            }
        </MudPaper>
    </MudItem>
</MudGrid>


@code {
    private Timer? _timer;
    private Timer? _chartRefreshTimer;
    private ApexChartOptions<ChartDataPoint> _temperatureChartOptions = new();
    private ApexChartOptions<ChartDataPoint> _fanChartOptions = new();
    private ApexChartOptions<ChartDataPoint> _powerChartOptions = new();
    private ApexChart<ChartDataPoint>? _temperatureChart;
    private ApexChart<ChartDataPoint>? _fanChart;
    private ApexChart<ChartDataPoint>? _powerChart;

    private List<ChartDataPoint> _chartData = new();
    private List<SensorData> _liveCpuData = new();
    private List<SensorData> _liveFanData = new();
    private SensorData? _livePowerData;
    
    private readonly Dictionary<string, (double Hour, double Day, double Week, double Month, double Min, double Max)> _tempAverages = new();
    private (double Hour, double Day, double Week, double Month, double Min, double Max) _powerAverages;
    private readonly Dictionary<string, (double Hour, double Day, double Week, double Month, double Min, double Max)> _fanAverages = new();

    // Loading states for skeleton screens
    private bool _isLiveDataLoading = true;
    private bool _isStatsLoading = true;
    private bool _isChartLoading = true;
    private bool _hasDataEverLoaded = false;

    // Performance optimization variables
    private int _selectedTimeRange = 24; // Hours
    private DateTime _lastDataUpdate = DateTime.MinValue;
    private DateTime _lastChartUpdate = DateTime.MinValue;
    private readonly Dictionary<int, List<ChartDataPoint>> _chartDataCache = new();
    private const int MaxChartPoints = 150;
    private int _chartRefreshIntervalSeconds = 0; // 0 = disabled
    private int _liveDataRefreshCount = 0;
    private const int ChartRefreshEveryNLiveUpdates = 12; // Refresh charts every 12 live updates (60 seconds if live updates every 5 seconds)

    protected override void OnInitialized()
    {
        ThemeService.OnThemeChanged += OnThemeChanged;
        LocalizationService.OnLanguageChanged += StateHasChanged;
        InitializeChartOptions();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Load chart refresh interval setting
            await using var scope = ScopeFactory.CreateAsyncScope();
            var settingService = scope.ServiceProvider.GetRequiredService<AppSettingService>();
            _chartRefreshIntervalSeconds = await settingService.GetIntSettingAsync("DashboardChartRefreshSeconds", 0);
            
            // Load data asynchronously after first render
            _ = Task.Run(async () =>
            {
                await LoadLiveDataOnly();
                await InvokeAsync(StateHasChanged);
                
                // Load statistics in background
                _ = Task.Run(async () =>
                {
                    await LoadStatistics();
                    _isStatsLoading = false;
                    await InvokeAsync(StateHasChanged);
                });
                
                // Load chart data in background
                _ = Task.Run(async () =>
                {
                    await LoadChartData();
                    _isChartLoading = false;
                    await InvokeAsync(StateHasChanged);
                });
            });
            
            _timer = new Timer(_ => 
            {
                try
                {
                    _ = InvokeAsync(LoadLiveDataOnly);
                }
                catch (Exception ex)
                {
                    LoggerService.Error("Error in live data timer callback", ex);
                }
            }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
            
            // Setup chart refresh timer if enabled
            if (_chartRefreshIntervalSeconds > 0)
            {
                _chartRefreshTimer = new Timer(_ => 
                {
                    try
                    {
                        _ = InvokeAsync(RefreshChartData);
                    }
                    catch (Exception ex)
                    {
                        LoggerService.Error("Error in chart refresh timer callback", ex);
                    }
                }, null, TimeSpan.FromSeconds(_chartRefreshIntervalSeconds), 
                    TimeSpan.FromSeconds(_chartRefreshIntervalSeconds));
            }
        }
    }

    private async void OnThemeChanged()
    {
        InitializeChartOptions();
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnTimeRangeChanged(int newRange
)
    {
        _selectedTimeRange = newRange;
        _isChartLoading = true;
        _chartDataCache.Remove(newRange); // Clear cache for this range
        StateHasChanged();
        
        await LoadChartData();
        _isChartLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadLiveDataOnly()
    {
        try
        {
            await using var scope = ScopeFactory.CreateAsyncScope();
            var db = scope.ServiceProvider.GetRequiredService<DatabaseService>().Db;

            var latestTimestamp = await db.Queryable<SensorData>()
                .MaxAsync(s => s.Timestamp);

            if (latestTimestamp == default)
            {
                // Only clear data if we haven't loaded any data yet
                if (!_hasDataEverLoaded)
                {
                    _liveCpuData.Clear();
                    _liveFanData.Clear();
                    _livePowerData = null;
                }
                // If data was loaded before but not now, keep showing old data
                // This prevents "No data available" flash when IPMI polling is in progress
                _isLiveDataLoading = false;
                return;
            }

            var latestData = await db.Queryable<SensorData>()
                .Where(s => s.Timestamp == latestTimestamp)
                .ToListAsync();

            // Only update if we got actual data
            if (latestData != null && latestData.Any())
            {
                var newCpuData = latestData.Where(d => d.SensorType == "Temperature").ToList();
                var newFanData = latestData.Where(d => d.SensorType == "Fan" && d.SensorName != "Fan Redundancy").ToList();
                var newPowerData = latestData.FirstOrDefault(d => d.SensorName == "Pwr Consumption");

                // Only update if we have new data, otherwise keep old data
                if (newCpuData.Any() || newFanData.Any() || newPowerData != null)
                {
                    if (newCpuData.Any()) _liveCpuData = newCpuData;
                    if (newFanData.Any()) _liveFanData = newFanData;
                    if (newPowerData != null) _livePowerData = newPowerData;
                    _hasDataEverLoaded = true;
                }
            }
            
            _isLiveDataLoading = false;

            // Refresh statistics periodically
            if (DateTime.Now - _lastDataUpdate > TimeSpan.FromMinutes(1))
            {
                _ = Task.Run(async () =>
                {
                    await LoadStatistics();
                    _lastDataUpdate = DateTime.Now;
                    await InvokeAsync(StateHasChanged);
                });
            }

            // Auto-refresh charts periodically (every 60 seconds by default)
            _liveDataRefreshCount++;
            if (_liveDataRefreshCount >= ChartRefreshEveryNLiveUpdates && 
                DateTime.Now - _lastChartUpdate > TimeSpan.FromSeconds(55))
            {
                _liveDataRefreshCount = 0;
                _ = Task.Run(async () =>
                {
                    await RefreshChartData();
                    _lastChartUpdate = DateTime.Now;
                });
            }
        }
        catch (Exception ex)
        {
            LoggerService.Error("Failed to load live data", ex);
            _isLiveDataLoading = false;
        }
    }

    private async Task LoadStatistics()
    {
        try
        {
            await using var scope = ScopeFactory.CreateAsyncScope();
            var db = scope.ServiceProvider.GetRequiredService<DatabaseService>().Db;

            var now = DateTime.Now;
            var hourAgo = now.AddHours(-1);
            var dayAgo = now.AddDays(-1);
            var weekAgo = now.AddDays(-7);
            var monthAgo = now.AddDays(-30);

            // Load all sensor data from the past month in one query
            var allData = await db.Queryable<SensorData>()
                .Where(s => s.Timestamp >= monthAgo && 
                           s.SensorName != null &&
                           (s.SensorType == "Temperature" || 
                            s.SensorType == "Fan" || 
                            s.SensorName == "Pwr Consumption"))
                .Select(s => new { s.SensorName, s.SensorType, s.Reading, s.Timestamp })
                .ToListAsync();

            // Group data by sensor name and type for efficient processing
            var groupedData = allData.GroupBy(s => new { s.SensorName, s.SensorType });

            foreach (var group in groupedData)
            {
                var sensorName = group.Key.SensorName;
                var sensorType = group.Key.SensorType;
                if (string.IsNullOrEmpty(sensorName)) continue;

                // Convert to list once and pre-filter by time ranges
                var allSensorData = group.OrderBy(s => s.Timestamp).ToList();
                var hourData = allSensorData.Where(s => s.Timestamp >= hourAgo).ToList();
                var dayData = allSensorData.Where(s => s.Timestamp >= dayAgo).ToList();
                var weekData = allSensorData.Where(s => s.Timestamp >= weekAgo).ToList();
                
                // Calculate statistics from pre-filtered data
                var stats = (
                    Hour: hourData.Any() ? hourData.Average(s => s.Reading) : 0,
                    Day: dayData.Any() ? dayData.Average(s => s.Reading) : 0,
                    Week: weekData.Any() ? weekData.Average(s => s.Reading) : 0,
                    Month: allSensorData.Any() ? allSensorData.Average(s => s.Reading) : 0,
                    Min: allSensorData.Any() ? allSensorData.Min(s => s.Reading) : 0,
                    Max: allSensorData.Any() ? allSensorData.Max(s => s.Reading) : 0
                );

                // Store in appropriate dictionary based on sensor type
                if (sensorName == "Pwr Consumption")
                {
                    _powerAverages = stats;
                }
                else if (sensorType == "Temperature")
                {
                    _tempAverages[sensorName] = stats;
                }
                else if (sensorType == "Fan")
                {
                    _fanAverages[sensorName] = stats;
                }
            }
        }
        catch (Exception ex)
        {
            LoggerService.Error("Failed to load statistics", ex);
        }
    }

    private async Task LoadChartData()
    {
        try
        {
            if (_chartDataCache.TryGetValue(_selectedTimeRange, out var cachedData))
            {
                _chartData = cachedData;
                return;
            }

            await using var scope = ScopeFactory.CreateAsyncScope();
            var db = scope.ServiceProvider.GetRequiredService<DatabaseService>().Db;

            var now = DateTime.Now;
            var startTime = now.AddHours(-_selectedTimeRange);
            var totalMinutes = _selectedTimeRange * 60;
            var intervalMinutes = Math.Max(1, totalMinutes / MaxChartPoints);

            var rawData = await db.Queryable<SensorData>()
                .Where(s => s.Timestamp >= startTime)
                .GroupBy(s => new { 
                    s.SensorName,
                    s.SensorType,
                    Year = s.Timestamp.Year,
                    Month = s.Timestamp.Month,
                    Day = s.Timestamp.Day,
                    Hour = s.Timestamp.Hour,
                    MinuteGroup = s.Timestamp.Minute / intervalMinutes
                })
                .Select(g => new {
                    SensorName = g.SensorName,
                    SensorType = g.SensorType,
                    Timestamp = SqlSugar.SqlFunc.AggregateMin(g.Timestamp),
                    Reading = SqlSugar.SqlFunc.AggregateAvg(g.Reading)
                })
                .ToListAsync();

            _chartData = rawData
                .OrderBy(d => d.Timestamp)
                .Select(d => new ChartDataPoint { T = d.Timestamp, V = d.Reading, N = d.SensorName, S = d.SensorType })
                .ToList();

            _chartDataCache[_selectedTimeRange] = _chartData;
        }
        catch (Exception ex)
        {
            LoggerService.Error("Failed to load chart data", ex);
        }
    }


    private void InitializeChartOptions()
    {
        var theme = ThemeService.IsDarkMode ? Mode.Dark : Mode.Light;

        _temperatureChartOptions = new ApexChartOptions<ChartDataPoint>
        {
            Theme = new Theme { Mode = theme },
            Chart = new Chart { 
                Zoom = new Zoom { Enabled = true }, 
                Type = ApexCharts.ChartType.Line,
                Animations = new Animations { Enabled = false }
            },
            Xaxis = new XAxis { 
                Type = XAxisType.Datetime,
                Labels = new XAxisLabels { Rotate = -45, Style = new AxisLabelStyle { FontSize = "12px" } }
            },
            Yaxis = [new YAxis { Title = new AxisTitle { Text = "°C" } }],
            Tooltip = new Tooltip { 
                Shared = true, Intersect = false,
                X = new TooltipX { Show = true, Format = "dd MMM yyyy HH:mm" },
                Y = new TooltipY { Formatter = "function(val) { return val.toFixed(1) + ' °C'; }" }
            },
            Stroke = new Stroke { Curve = Curve.Straight, Width = 2 },
            Markers = new Markers { Size = 0 },
            DataLabels = new DataLabels { Enabled = false },
            Legend = new Legend { Show = true, Position = LegendPosition.Bottom }
        };

        _fanChartOptions = new ApexChartOptions<ChartDataPoint>
        {
            Theme = new Theme { Mode = theme },
            Chart = new Chart { 
                Zoom = new Zoom { Enabled = true }, 
                Type = ApexCharts.ChartType.Line,
                Animations = new Animations { Enabled = false }
            },
            Xaxis = new XAxis { 
                Type = XAxisType.Datetime,
                Labels = new XAxisLabels { Rotate = -45, Style = new AxisLabelStyle { FontSize = "12px" } }
            },
            Yaxis = [new YAxis { Title = new AxisTitle { Text = "RPM" } }],
            Tooltip = new Tooltip { 
                Shared = true, Intersect = false,
                X = new TooltipX { Show = true, Format = "dd MMM yyyy HH:mm" },
                Y = new TooltipY { Formatter = "function(val) { return val.toFixed(0) + ' RPM'; }" }
            },
            Stroke = new Stroke { Curve = Curve.Straight, Width = 2 },
            Markers = new Markers { Size = 0 },
            DataLabels = new DataLabels { Enabled = false },
            Legend = new Legend { Show = true, Position = LegendPosition.Bottom }
        };
        
        _powerChartOptions = new ApexChartOptions<ChartDataPoint>
        {
            Theme = new Theme { Mode = theme },
            Chart = new Chart { 
                Zoom = new Zoom { Enabled = true }, 
                Type = ApexCharts.ChartType.Area,
                Animations = new Animations { Enabled = false }
            },
            Xaxis = new XAxis { 
                Type = XAxisType.Datetime,
                Labels = new XAxisLabels { Rotate = -45, Style = new AxisLabelStyle { FontSize = "12px" } }
            },
            Yaxis = [new YAxis { Title = new AxisTitle { Text = "Watts" } }],
            Tooltip = new Tooltip { 
                Shared = true, Intersect = false,
                X = new TooltipX { Show = true, Format = "dd MMM yyyy HH:mm" },
                Y = new TooltipY { Formatter = "function(val) { return val.toFixed(1) + ' W'; }" }
            },
            Stroke = new Stroke { Curve = Curve.Straight, Width = 2 },
            Markers = new Markers { Size = 0 },
            DataLabels = new DataLabels { Enabled = false },
            Legend = new Legend { Show = true, Position = LegendPosition.Bottom },
            Fill = new Fill
            {
                Type = FillType.Gradient,
                Gradient = new FillGradient
                {
                    Shade = theme == Mode.Dark ? GradientShade.Dark : GradientShade.Light,
                    Type = GradientType.Vertical,
                    OpacityFrom = 0.7,
                    OpacityTo = 0.3
                }
            }
        };
    }

    private async Task RefreshChartData()
    {
        try
        {
            _chartDataCache.Remove(_selectedTimeRange); // Clear cache for current range
            await LoadChartData();
            
            // Force charts to update with new data
            if (_temperatureChart != null)
                await _temperatureChart.RenderAsync();
            if (_powerChart != null)
                await _powerChart.RenderAsync();
            if (_fanChart != null)
                await _fanChart.RenderAsync();
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            LoggerService.Error("Failed to refresh chart data", ex);
        }
    }

    private async Task ManualRefreshCharts()
    {
        _isChartLoading = true;
        await InvokeAsync(StateHasChanged);
        
        await RefreshChartData();
        
        _isChartLoading = false;
        _lastChartUpdate = DateTime.Now;
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _chartRefreshTimer?.Dispose();
        ThemeService.OnThemeChanged -= OnThemeChanged;
        LocalizationService.OnLanguageChanged -= StateHasChanged;
        _chartDataCache.Clear();
    }
}
